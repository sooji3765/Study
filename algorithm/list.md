# List

 배열 : 같은 타입 변수들을 하나의 이름으로 열거하여 사용하는 자료 구조 , 처음 지정 후 변경이 불가능
 리스트 : 다양한 데이터를 저장할수 있으며 가변적으로 변경이 가능함

 ~~~java
 int[] num = {1,5,6,8,8};
 ~~~

 시퀀스 자료형
 - 순서가 존재함으로 인덱싱과 슬라이싱의 연산 모두 적용가능
 - `인덱싱` : 시퀀스 자료형에서 하나의 요소를 인덱스 연산자를 통하여 참조
 - `슬라이싱` : 시퀀스 자료형의 원하는 범위를 선택하는 연산
 - 시퀀스 자료형이 지원하는 연산 가능

 리스트 함축
 - 수학에서 집합을 정의하는 표현식과 유사함

# Exhaustive Search : 완전 검색

> 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

1. Brute-force 혹은 Generate-and-Test 기법
2. 모든 경우의 수를 테스트한 후, 최종 해법을 도출함
3. 일반적으로 경우의 수가 상대적으로 작을 때 유용함
4. 모든 경우의 수를 생성하고 테스트하기 때문에 수행속도는 느리지만, 해답을 찾아낼 확률이 높음
5. 완전 검색으로 접근하여 해답을 도출

> 순열 : 서로 다른 것들 중 몇 개를 뽑아서 한줄로 나열

# Greedy Algorithm : 탐욕 알고리즘

> 최적 해를 구하는데 사용되는 근시안적인 방법

> 수행과정
1. 부분 해 집합에 추가
2. 실행 가능한지 확인, 문제의 제약 조건 위반 여부 검사
3. 문제의 해가 되는지 확인


# sort

> 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값으로 정렬

#### 정렬 종류

1. 버블정렬 : 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식
    시간복잡도 : O(N^2)

    ##### 정렬 방법
    1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
    2. 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬
    3. 교환하며 자리를 이동하는 모습이 거품모양 같아서 버블 정렬이라함

    ![buble](http://cfile5.uf.tistory.com/image/265C7C3B54C20190083A30)

    if


2. 카운팅 정렬
3. 선택정렬
4. 퀵정렬
5. 삽입정렬
6. 병합정렬
