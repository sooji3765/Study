##신입 프로그래머 기술


1. 데이터베이스
2. 자료구조
3. 운영체제
4. 네트워크
5. 보안관련
6. 프로그래밍 기본
7. 웹 프로그래밍
8. 자바프로그래밍




> 데이터베이스
###### PK, FK, ER모델이란?
- Primary Key: 관계형 DB에서 레코드(튜플)의 식별자로 이용하기에 가장 적합한 것을 후보키 중에 하나 선택한 것
-  Foreign Key: 관계형 DB에서 한 테이블의 키 중 다른 테이블의 튜플을 식별할 수 있는 -
- ER-Model: 관계형 데이터베이스와 같은 데이터 관리 시스템 상의 구조적인 데이터를 기술하는 것. 개체(Entity)와 관계(Relationship)을 이용해 현실에서의 데이터 세계를 개념적으로 표현한다.


###### 참조 무결성이란?
- 외래키 값은 NULL이거나 참조 테이블(릴레이션)의 기본키(Primary Key)값과 동일해야한다.
- 관계 데이터베이스 관계 모델에서 관련된 테이블 간의 일관성(데이터 무결성)을 말한다.
- 사용자의 실수로 관련 데이터가 삭제되거나 수정되는 것을 막아준다.
**참조 무결성 제약 조건 : 기본 테이블에서 일치하는 필드가 기본키(PK)이거나 고유 인덱스를 갖고 있거나 관련 필드의 데이터 형식이 같아야 한다.**

######DBMS란?
- 데이터베이스라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용프로그램이다.
- 다수의 컴퓨터 사용자들이 컴퓨터에 수록 된 수 많은 자료들을 쉽고 빠르게 추가, 수정, 삭제 할수 있도록 해주는 시스템
- 데이터베이스 내의 정보를 검색하거나 정보를 저장하기 편리하고 효율적인 환경을 제공하는 것이 목적
- 대표적인 세 가지 기능 : 구성, 조작, 제어
(1)구성 : 데이터베이스에 저장될 자료의 구조와 응용 프로그램이 그것을 이용하는 방식을 정의(레코드 구조, 데이터 보형, 물리적 구조 등)
(2)조작 : 사용자 도구에 따라 데이터베이스에 저장된 자료를 검색, 갱신, 삽입, 삭제 할 수 있도록 지원
(3)제어 : 데이터베이스의 내용에 대한 일관성, 중복제거, 접근제어에 대한 기능을 지원


######RDBMS란?
- 관계형 데이터베이스 관리 시스템, RDB를 관리하기 위한 소프트웨어 또는 그것이 설치된 시스템을 말한다.
- RDBMS 종류 : Oracle DBMS, MySQL, MS Access 등
- 모든 데이터를 2차원 테이블로 표현 및 상호 관련성을 가진 테이블의 집합을 만들거나 이용하기도 비교적 쉽지만, 무엇보다도 확장이 용이하다는 장점을 가짐
- SQL(Structured Query Language)은 데이터베이스와 통신하기 위한 언어

###### DB에서의 Commit과 Rollback이란?
 - Commit : 작성한 쿼리문에서 Update, Delete, Insert를 수행했을 때, 그 쿼리문 수행결과에 대해 확정을 짓 겠다는 뜻이다.
 - Rollback : 쿼리문 수행결과에 대해 번복을 함. 즉, 쿼리문 수행 이전으로 원상복귀 하겠다는 뜻이다(Commit 하기 전에 사용됨).

###### DB Nomalization(정규화)란?
  - DB정규화란(개요)?
관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스
  - DB정규화의 목적?
  데이터 구조의 안정성 최대화, 효과적인 검색 알고리즘(Query), 중복 배제를 통한 DML(Data Manipulation Language) 이상 발생 방지
- 논리적 데이터베이스 설계에 있어서 테이블들을 구조화하는 기법 중 하나
- 자료의 손실이나 불필요한 정보의 도입 없이 데이터의 일관성 및 데이터 중복을 최소화하고 최대의 데이터 안정성 확보를 위한 안정적 자료구조로 변환하기 위해서 하나의 테이블을 둘 이상으로 분리하는 작업

(1)제1정규형(1NF) : 테이블의 각 셀의 값은 단일값을 가진다.
(2)제2정규형(2NF) : 주키가 합성키며 부분종속이 존재할 경우 2차 정규형의 대상이 된다.
(3)제3정규형(3NF) : 비주키 속성 간에 발생하는 함수적 종속(이전종속)이 발생하면 3차 정규형의 대상이 된다.


######DB Nomalization(정규화)의 목적은?
- 저장 공간 최소화
- 데이터 무결성 유지
- 자료구조의 안정성 최대화

###### SQL이란?
- Structured Query Language의 약자로 구조화 질의어라고 한다.
- 데이터 정의어(DDL)와 데디터 조작어(DML)을 포함한 데이터베이스 용 질의 언어(Query Language)의 일종으로 데이터베이스를 사용할 때 데이터베이스에 접근할 수 있는 데이터베이스 하부 언어를 뜻한다.

######DB Transaction(트랜잭션)이란?
- 데이터의 무결성으로 인하여 데이터 작업 시에 문제가 생기면, 데이터 작업을 하기 이전 시점으로 모든 데이터를 원상복구 하는 것을 말한다.
**즉, 모두 실행되거나 모두 실행되지 않거나를 뜻한다.**
- 트랜잭션의 필요성 : 여러 작업이 한 자원에서 동시에 변경, 참조 필요시. / 작업공정이 긴 경우.
 - 트랜잭션의 시작   : 첫 DML(data조작어)구문이 실행될 때. (SELECT에선 제외), 사용자가 ASVEPOINT를 설정할 때.

- 커밋과 롤백 전:  롤백으로 데이터 회복 가능 , 현재 유저는 자신이 바꾼 데이터 확인 가능
  ,다른 유제에게는 바뀐 데이터 내용이 반영되지 않음, 영향받은 레코드는 잠금 상태
 - 커밋 후 : 데이터는 영구적으로 변경  ,복구 불가능 , 세이브 포인트 삭제
 ? 모든 유저에게 변경 내용 반영 ,해당 레코드 잠금 해제, 다른 유저들이 다룰 수 있음
 - 롤백 후  : 데이터의 변경 취소 , 데이터 이전 상태 회복  , 데이터에 대한 잠금 해제

######RDB에서 Join이 무엇인지에 대한 설명과 간단한 샘플 쿼리문을 작성해보아라

- Join이란 2개 이상의 테이블에서 조건에 맞는 데이터를 추출하기 위하여 사용

* Inner Join : 2개 이상의 테이블에서 교집합만을 추출
* Left Join : 2개 이상의 테이블에서 from에 해당하는 부분을 추출
* Right Join : 2개 이상의 테이블에서 from과 JOIN하는 테이블에 해당하는 부분을 추출
* Outer Join : 아웃터 조인 또는 풀 조인이라고 불림, 2개 이상의 테이블에서 모든 테이블에 해당하는 부분을 추출
Inner) SELECT user.name, course.name FROM user INNER JOIN course ON user.course=course.id;

Left) SELECT user.name, course.name FORM user LEFT JOIN cource On user.course=course.id;

Right) SELECT user.name, course.name FORM user RIGHT JOIN cource On user.course=course.id;

Outer) SELECT user.name, cou rse.name FORM user Outer JOIN cource On user.course=course.id;
* 가장 많이 쓰이는 Join은 Inner Join.

######DB에서 Index를 사용하는 이유는?
- 인덱스(Index)는 데이터를 논리적으로 정렬하여 검색과 정렬 작업의 속도를 높이기 위해 사용된다.
- 예를 들면, 책에서 가장 빨리 내용을 찾는 방법은 책의 뒤편의 색인을 보는 것.
기본키에 대해서는 항상 DBMS가 내부적으로 정렬된 목록을 관리하기에 특정 행을 가져올 때 빠르게 처리된다. 하지만, 다른 열의 내용을 검색하거나 정렬시에는 하나하나 대조를 해보기 때문에 시간이 오래 걸린다(이를 인덱스로 정의해두면 검색 속도가 향상된다).

- 단점 : 인덱스를 사용하면 데이터를 가져오는 작업의 성능은 향상시킬 수 있지만 데이터 삽입, 변경 등이 일어날 떄 매번 인덱스가 변경되기 떄문에 성능이 떨어질 수 있다.

- 사용대상 : 데이터 필터링과 정렬에 사용되므로, 데이터를 특정한 순서로 자주 정렬한다면 인덱스를 사용하기에 적합

- DB에서 자료를 검색하는 두 가지 방법

  FTS(Full Table Scan) : 테이블을 처음 부터 끝까지 검색하는 방법
  Index Scan : 인덱스를 검색하여 해당 자료의 테이블을 액세스 하는 방법.


###### PROCEDURE
  - PL/SQL에서 가장 대표적인 구조인 스토어드 프로시저는 개발자가 자주 실행해야 하는 업무 흐름을 미리 작성하여 데이터베이스 내에 저장해 두었다가 필요할 때마다 호출하여 실행할 수 있다.

###### CURSOR
  - 오라클에서는 하나의 레코드가 아닌 여러 레코드로 구성된 작업영역에서 SQL문을 실행하고 그 과정에 생긴 정보를 저장하기 위해서 CURSOR를 사용하며, 커서에는 암시적 커서와 명시적 커서가 있다.
  - 암시적 커서는 모든 SQL 문에 기본적으로 존재하며, SQL 문 실행 후 오직 하나의 row만 출력하게 된다. 그러나 SQL 문 실행한 결과물(result set)이 여러 row로 된 경우 CURSOR를 명시적으로 선언하여야 여러 row를 다룰 수 있다.
  - 또한 커서는 Private SQL의 작업영역 으로 오라클 서버에 의해 실행되는 모든 SQL문은 연관된 각각의 커서를 소유하고 있다.

######NoSQL이란?
- NoSQL 데이터베이스는 관계형 데이터베이스(RDB) 보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공한다.
- 단순 검색 및 추가 작업을 위한 매우 최적화된 키-값(Key-Value) 저장 공간을 사용한다.
- 빅데이터 시대에 따라 많은 양의 데이터를 효율적으로 처리하기 위해 등장하였다(분산처리, 빠른 쓰기 및 데이터의 안정성).
- 분산형 구조를 통해 데이터를 여러 대의 서버에 분산해 저장하고, 분산 시에 데이터를 상호 복제해 특정 서버에 장애가 발생했을 때에도 데이터 유실이나 서비스 중지가 없는 형태의 구조를 갖고 있다.

######NoSQL이 기존 RDBMS와 다른 점은?
- 스키마가 없다. 즉 데이터 관계와 정해진 규격(table-column의 정의)이 없다.
관계 정의가 없으니 Join이 불가능하다(하지만 reference와 같은 기능으로 비슷하게 구현은 가능).
- 트랜잭션을 지원하지 않는다.
- 분산처리(수평적 확장)의 기능을 쉽게 제공한다.
-  대부분의 NoSQL DB는 분산처리기능을 목적으로 나왔기 때문에 분산처리 기능을 자체 프레임워크에 포함하고 있다.



>자료구조

###### 스택(Stack)에 대해 설명하시고 예제소스를 구현해보아라

- 스택은 LIFO(Last In First Out)의 원리로 동작하는 선형적인 자료 구조이다.
- 데이터가 들어가고 나오는 입구가 하나뿐이므로 입구로 들어간 데이터가 스택에 차곡차곡 쌓여 있다가 들어간 반대 순서로 나온다.
- 주로 계산중에 잠시 기억해야 하는 임시적인 자료를 관리하는 용도로 사용된다.
- CPU도 여러 가지 정보를 저장하기 위해 스택을 사용하는데 이를 시스템 스택이라 한다.

<pre><code>
int *Stack;
int Size;
int Top;

void InitStack(int aSize)
{
     Size=aSize;
     Stack=(int *)malloc(Size*sizeof(int));
     Top=-1;
}

void FreeStack()
{
     free(Stack);
}

BOOL Push(int data)
{
     if (Top < Size-1) {
          Top++;
          Stack[Top]=data;
          return TRUE;
     } else {
          return FALSE;
     }
}

int Pop()
{
     if (Top >= 0) {
          return Stack[Top--];
     } else {
          return -1;
     }
}

void main()
{
     InitStack(256);
     Push(7);
     Push(0);
     Push(6);
     printf("%d\n",Pop());
     printf("%d\n",Pop());
     printf("%d\n",Pop());
     FreeStack();
}*
</code></pre>

###### 큐(Queue)에 대해 설명하시고 예제소스를 구현해보아라

- 큐는 FIFO(First In First Out)의 원리대로 동작하는 자료 구조이다. 동일한 자료의 집합을 다룬다는 면에 있어서는 스택과 비슷하지만, 가장 먼저 들어간 자료가 가장 늦게 나온다는 점이 다르다.

- 넣은 순서대로 자료를 꺼내가므로 순서대로 처리해야하는 자료를 임시적으로 저장하는 용도로 흔히 사용한다.

- 저장되는 자료의 타입이 동일하므로 배열 또는 연결리스트로 큐를 구현할 수 있다.


<pre><code>
int *Queue;
int QSize;
int head,tail;

void InitQueue(int size)
{
     QSize=size;
     Queue=(int *)malloc(QSize*sizeof(int));
     head=tail=0;
}

void FreeQueue()
{
     free(Queue);
}

BOOL Insert(int data)
{
     if ((tail+1) % QSize == head) {
          return FALSE;
     }
     Queue[tail]=data;
     tail=(tail+1) % QSize;
     return TRUE;
}

int Delete()
{
     int data;

     if (head==tail) {
          return -1;
     }
     data=Queue[head];
     head=(head+1) % QSize;
     return data;
}

void main()
{
     int i;

     InitQueue(10);
     printf("빈 상태에서 삭제할 때 = %d\n",Delete());
     for (i=0;i<9;i++) {
          Insert(i);
     }

     printf("가득찬 상태에서 삽입 %s\n",Insert(100) ? "성공":"실패");

     for (i=0;i<9;i++) {
          printf("%d  ",Delete());
     }

     FreeQueue();
}*
</code></pre>

###### 단순 연결리스트에 대해 설명하시고 예제소스를 구현해보아라

- 연결리스트는 동적배열과 같이 같은 타입의 데이터 여러 개를 저장할 수 있는 가변 크기를 가지는 자료구조이다.
- 동적배열과 달리 연결리스트는 요소들이 링크에 의해 논리적으로 연결되어 있어 링크를 따라가면 이전, 이후 요소들을 찾을 수 있다. 이러한 특징 때문에 삽입, 삭제를 할 때도 물리적인 메모리 이동없이 요소간의 링크만 조작하면 되므로 동적배열에 비해 속도가 빠르다는 차이점이 있다.

- 배열의 요소 하나는 자신이 기억할 데이터 값만을 가지는데 비해 연결리스트의 요소인 노드는 데이터 외에 연결 상태에 대한 정보인 링크를 추가로 가져야한다. 자기 다음의 요소가 누구인지를 스스로 기억하고 있어야 흩어져 있는 노드들의 순서를 알 수 있는데 이 연결 정보를 저장하는 것이 바로 링크이다. 이때 링크를 하나만 가지는 것을 단순 연결리스트(Single Linked List)라고 하고 두 개의 링크를 가지는 것을 이중 연결리스트(Double Linked List)라고 한다. 노드를 구성하는 데이터와 링크는 타입이 다르기 때문에 노드는 이형 타입의 집합인 구조체로 정의한다.
* 구조체로 정의된 노드
<pre><code>
struct Node
{
     int value;     //데이터
     Node *next;    //링크
}*
</code></pre>

- value 멤버는 노드가 기억하는 정보의 실체인 데이터이다. 배열 요소 타입에 제한이 없는 것처럼 연결 리스트가 저장하는 정보의 종류에도 제한이 없으므로 노드의 데이터는 임의 타입, 임의 개수로 정의할 수 있다. 여러 개의 변수들을 한꺼번에 가질 수도 있고 포인터나 배열 또는 다른 구조체를 노드에 포함시키는 것도 물론 가능하다. 위 예제 코드에서는 편의상 정수값 하나만을 노드에 포함시켰다.

- next 멤버는 다음 노드에 대한 포인터를 가지는 링크이다. Node 구조체안에 다른 Node 구조체의 번지 정보가 포함되어 있는데 자신에 대한 포인터를 멤버로 가지는 가지 참조 구조체이므로 무한대가 되지는 않는다. 이 포인터가 가리키는 곳을 찾아가면 다음 노드가 저장된 곳을 알 수 있다. 노드들이 링크를 통해 서로의 위치를 기억함으로써 물리적으로 흩어져 있더라도 논리적으로는 한 덩어리의 정보가 될 수 있는 것이다(단, 어떤 노드가 연결리스트의 첫 번째 노드인지는 따로 저장해야 하는데 이를 머리(head)라고 한다).



[23] 이중 연결리스트에 대해 설명하시고 예제소스를 구현해보아라



[24] 순차검색(Sequential Search)에 대해 설명하시고 예제소스를 구현해보아라



[25] 이분검색에 대해 설명하시고 예제소스를 구현해보아라



[26] 재귀함수를 이용하여 피보나치수열을 구현해보아라



[27] 재귀함수를 이용하여 팩토리얼을 구현해보아라



[28] 버블 정렬에 대해 설명하시고 예제소스을 구현해보아라



[29] 선택 정렬에 대해 설명하시고 예제소스을 구현해보아라



[30] 삽입 정렬에 대해 설명하시고 예제소스을 구현해보아라



[31] 퀵 정렬에 대해 설명하시고 예제소스을 구현해보아라



[32] 싱글톤에 대해 설명하시고 예제소스을 작성해보아라







> 운영체제

######세마포어와 뮤텍스에 대해 각 설명하시고 차이점에 대해 설명해보아라

- 세마포어(Semaphore) - 운영체계 또는 프로그램 작성 내에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호이다. 공유 자원에 접근할 수 있는 최대 허용치만큼만 동시에 사용자 접근이 가능하다. 스레드들은 리소스 접근 요청을 할 수 있고 세마포어에서는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용 중 인 경우(카운트 0) 다음 작업은 대기를 하게 된다.

- 뮤텍스(Mutex) - 상호배제, 제어되는 섹션에 하나의 스레드만을 허용하기 때문에 해당 섹션에 접근하려는 다른 스레드들을 강제적으로 막음으로써 첫 번째 스레드가 해당 섹션을 빠져나올 때 까지 기다린다. 대기열(큐) 구조라고 생각하면 된다.
- 차이점 - 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다 /세마포어는 소유 불가능이지만 뮤텍스는 소유가 가능하다 / 동기화의 갯수가 다르다



> 보안

###### 대칭키와 비대칭키에 대해 각 설명하시고 대표 암호화 알고리즘과 차이점에 대해 설명해보아라
- 대칭키 : 대칭키(Symmetric Key) 암호화 방식은 암호화와 복호화에 같은 암호 키(대칭키)를 사용하는 암호화 알고리즘이다. 후술할 공개키 암호화 방식에 비해 암호화 및 복호화가 빠르다는 장점이 있다. 하지만, 암호화 통신을 하는 사용자끼리 같은 대칭키를 공유해야만 한다는 단점이 있다.

 ![info](http://cfile5.uf.tistory.com/image/2168D83F587B369B26FFD8)

- 비대칭키 : 공개키(Public Key) 암호화 방식은, 암호화와 복호화에 사용하는 암호키를 분리한 방식이다. 자신이 가지고 있는 고유한 암호키(비밀키, Private Key)로만 복호화할 수 있는 암호키(공개키, Public Key)를 대중에 공개한다.

![info2](http://cfile7.uf.tistory.com/image/242B243B587B395323A075)
- 공개키 암호화 방식을 이용한 암호화 통신 시나리오는 다음과 같다. 먼저 A가 웹 상에 공개된 'B의 공개키'를 이용하여 평문을 암호화 한다. 이 암호문(CiperText)는 B가 개인적으로 가지고 있는 B의 비밀키로만 복호화가 가능하다. B는 자신의 비밀키로 복호화한 평문을 확인하고, A의 공개키로 응답을 암호화하여 A에게 보낸다. A는 자신의 비밀키로 암호화된 응답문을 복호화한다.

-  이처럼 공개키 암호화 방식은 (각자의 로컬에 저장된 비밀키가 해킹당하지 않는 한) 대칭키의 단점을 완벽하게 해결했다. 하지만 단점이 존재하는데, 암복호화가 매우 복잡하다는 점이다. 암복호화가 복잡한 이유는, 암호화하는 키와 복호화하는 키가 서로 다르기 때문이다.


>프로그래밍 기본


###### 자신이 알고 있는 언어에 대해서 모두 얘기해보아라
- 저급어 : 어셈블리어, C
- 중급어 : C++
- 고급어 : JAVA, C#
- JAVASCRIPT, RUBY, PYTHON, VISUAL BASIC 등

###### OOP(객체지향)에 대해서 설명하고 절차지향 프로그래밍과의 차이점에 대해서 설명해보아라

* 절차지향, 구조적 프로그래밍(C) : 초창기에 많이 사용한 방법으로 순차적 프로그래밍이라고도 한다. 해야할 작업을 순서대로 코딩을 한다. 구조적 프로그래밍에서는 함수 단위로 구성되며 기능별로 묶어놓은 특징이 있다.

* 객체지향 프로그래밍(JAVA, C++, C#) : 주 구성요소는 클래스와 객체이다. 그리고 상속과 다형성을 특징으로 들 수 있다. 클래스를 활용하여 각각의 기능별로 구성이 가능하며, 이를 나중에 하나로 합쳐서 프로그램의 완성이 가능하다. 객체 별로 개발이 가능하기에 팀 프로젝트를 하기에도 유리한 장점을 가지고 있다. 또한 코드의 재사용이 가능하며, 오류 발생 가능성이 적고 안정성이 높다.

######스크립트 언어와 컴파일 언어를 나열하고 차이점을 설명해보아라
- 스크립트 언어 : Javascript, Python, Ruby
- 컴파일 언어    : C, JAVA, C#, C++
**차이점 : 컴파일러의 존재 여부**
* 컴파일 언어의 경우, 컴파일러를 통해서 한번 컴파일 된 후에는 코드 수정 후 재 컴파일을 하기 전까지는 같은 결과를 나타내지만, 스크립트 언어의 경우 실행될 때 바로 해석하므로 코드 변경 시 실행 할 때 마다 결과가 바뀌게 된다.

###### 프로그램 ,프로세스와 스레드의 차이를 설명해보아라

- 프로그램은 <u>명령어들과 데이터의 묶음이라고 할 수 있다.</u> 운영체제가 프로그램에 메모리를 할당하여 실행하면 이를 프로세스라고 한다. CPU의 프로세서는 하나의 프로세스만 구동할 수 있다.

 - 운영체제는 하나의 CPU로 여러 개의 프로세스를 구동하기 위해 '시분할 방식'을 사용한다. (CPU는 매우 빠른 속도로 연산할 수 있으므로 아주 잠깐씩 여러개를 실행하면, 사용자는 동시에 여러개가 실행되는 것으로 느낀다.) 어떤 프로세스를 더 먼저 or 더 길게 실행할 것인지 스스로 판단하며 이에 관련된 다양한 기법이 존재한다.


* 프로세스 : 실행중인 프로그램을 나타낸다. 이는 CPU가 실행되고 있는 프로세스에 대해서 메모리 자원을 안정되게 분배해줘야 하며 이는 운영체제의 성능에 따라 결정된다.

* 스레드 : 하나의 프로그램이 동시에 하나 이상의 처리(process)를 수행하는 것을 의미한다.하나의 프로세스 내에서 할당 받은 자원을 공유하며 실행되는 독립적인 작업 단위이다. 즉, 스레드는 각자의 스택 메모리영역을 가지고 있으며 동일한 프로세스 내의 다른 스레드들과 전역 메모리를 공유한다. 따라서 CPU로부터 새로운 자원을 할당받지 않아도 되기 때문에 프로세스보다 실행 속도가 빠르다는 장점을 가지고 있다.

- Thread(쓰레드) - 프로세스내에서 동시에 실행되는 독립적인 실행 단위를 말함, 장점으로는 자원을 많이 사용하지 않고 구현이 쉬우며 범용성이 높다

- Process(프로세스) - 운영체제에서 실행중인 하나의 프로그램(하나 이상의 쓰레드를 포함한다.)

- Thread 장점
  - 빠른 프로세스 생성
  - 적은 메모리 사용
  - 쉬운 정보 공유

- Thread 단점
  - 교착상태에 빠질 수 있다.
  * 교착상태 - 다중프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 어떤 특정시간을 기다리고 있는 상태.

- Thread와 Process 차이
  여러 분야에서 '과정' 또는 '처리'라는 뜻으로 사용되는 용어로 컴퓨터 분야에서는 '실행중인 프로그램'이라는 뜻으로 쓰인다.
  이 프로세스 내에서 실행되는 각각의 일을 스레드라고 한다. 프로세스 내에서 실행되는 세부 작업 단위로 여러 개의 스레드가 하나의 프로세스를 이루게 되는 것이다.


- 스레드가 메모리를 공유함으로써 생기는 프로세스와의 차이점.
 ◎ 동시에 여러 작업을 할 때, 멀티 스레드가 시스템 자원을 더 적게 사용함.
 ◎ 프로세스는 메모리 공유를 하지 않으므로, 프로세스간 통신은 스레드간 그것에 비해 복잡함.
 ◎ 스레드의 경우 공유 자원에 대한 동기화(Synchronize)이슈 발생.

######싱글스레드 , 멀티스레드 차이
![Multi](http://cfile1.uf.tistory.com/image/213B8E4957E6490F23ADDF)



######스레드를 생성하는 방법과 스레드의 장 / 단점에 대해 설명하여라
* 생성방법 : Runnable(인터페이스)로 선언되어 있는 클래스를 상속받거나 Thread 클래스를 상속받아 run() 메소드를 구현해주면 된다.
* 장점 : 빠른 프로세스 생성, 적은 메모리 사용, 쉬운 정보 공유
* 단점 : 교착 상태에 빠질 수 있다.

######동기화란 무엇이며 어떠한 경우에 사용하는가?
- 다중 스레드에서 하나의 자료에 접근할 때 사용한다(static으로 선언되어 있거나 배열에 접근하는 경우).

- 예를들면, 은행계좌에 있는 돈에 대하여 동시에 출금 요청(접근)이 가능하다면 한 쪽에서 출금 처리가 완료되기 전에 다른 쪽에서 출금을 요청하면 출금이 될수 있기 때문에 반드시 동기화 처리를 해서 작업이 일어나는 중에는 다른 쪽에서의 접근을 막아주어야 한다.

- 여러 명이 접근 하는 것을 방지하기 위함. 이때 여러 명이 접근 하는 것을 막기 위해 모든 객체에 ‘락’을 포함 시키는데, ‘락’이란 공유 객체에 여러 스레드가 동시에 접근하지 못하도록 하기 위한 것으로 모든 객체가 힙 영역에 생성될 때 자동으로 만들어 짐.

######포인터의 개념에 대해 설명하고 이해할 수 있도록 풀어서 설명해보아라
* 포인터란 메모리 주소를 저장하는 변수이다.
예를 들면 주소를 지칭하고 있는 곳이다. 엘리베이터에서 포인터는 해당 층을 표시하는 버튼이며, 10층 버튼을 누르면 10층으로 이동하듯이 해당 위치를 가리키도 있는 변수이다.
* 포인터를 사용할 때 주의할 점은 어떠한 주소를 가리키고 있어야 사용이 가능하다.

######변수들이 메모리에 저장되는 영역에 대해서 설명해보아라
* bss영역   : 전역 변수로 선언되었으나 초기화되지 않은 변수
* stack영역 : 지역 변수, 객체의 지역 변수(프로그램에 의해서 자동적으로 호출되고 소멸되는 변수)
* heap영역 : 객체, 객체의 인스턴스 변수(멤버변수, 사용자에 의해서 생성되는 변수 및 객체들)

######call by reference와 call by value 방식의 차이점에 대해 설명하시고, 이를 활한 대표적인 코드를 작성해보아라

* call by reference : 매개변수로 원래 주소 값을 전달하는 방식, 자바에서는 객체를 매개변수로 전달하였을 경우에 해당한다.

* call by value      : 매개변수로 기본 데이터 형을 사용한다. 주어진 값을 복사하여 처리하는 방식으로 함수 내의 처리결과는 함수 밖의 변수에는 영향을 미치지 않는다(C언어의 Swap()).



###### 재귀함수에 대해 설명하시고 대표적인 소스코드를 작성해보아라

재귀함수란 함수 내에서 자기 자신을 다시 호출하는 형태

장점 : 소스코드의 간결화가 가능하다.

단점 : 연산 시간이 오래 걸린다. 또한, 잘못 작성 시 프로그램이 무한루프에 빠질 수 있다.




######디자인패턴을 사용하는 이유에 대해서 설명하시고, 대표적인 디자인 패턴 한 가지를 작성해보아라
- 디자인패턴이란, 여러 프로그래머들의 경험과 지혜를 모아서 공통적인 소프트웨어 디자인 문제를 해결하는데 도움이 될수 있게 만들어 놓은 것

가장 대표적인 디자인패턴으로는 싱글톤이 존재. 싱글톤이란 전체 프로그램에서 단 1개의 객체를 생성하고 공유하는데 사용하는 패턴이다. 주로 Android에서 소켓 객체를 사용할 때 사용한다.

* 코드 작성해서 추가할 것

** Singleton**
 -  싱글턴 패턴은 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴이다.
 -  프로그램 상에서 두 번째 인스턴스 를 만들 수 없게 한다(생성자를 private 으로 작성)
 - 예
 <pre><code>
   public class DBConn {
	private static Connection conn = null;

	private DBConn() {
	}

	public static Connection getConnection() {
                     :		
		return conn;
	}
  </code></pre>

######ORM이 무엇인지 설명해보아라

ORM이란 Object-Relational Mapping의 약자로써, 말 그대로 객체와 관계와의 설정이다.

여기서 말하는 객체라는 것은 우리가 흔히 말하는 OOP(Object-Oriented Programming)의 그 객체를 이야기한다.

관계는 우리가 흔히 사용하고 있는 관계형 데이터베이스를 의미한다.

앞서 설명한 내용을 연결짓자면, 객체와 관계형 데이터베이스 간의 매핑을 지원해주는 개념을 ORM이라 불리며 이와 관련된 여러 Framework나 Tool이 존재하고 있다.


######UML이란?
- Unified Modeling Language의 약자로 '객체 모델링 언어' 또는 '통합 모델링 언어'를 뜻한다.
- 시스템 설계, 요구분석, 시스템 구현 등의 과정에서 사용되는 모델링 언어로 표기법의 표준화를 목적으로 한다.
- 시스템에 대해 동일한 의미를 공유할 수 있게 하여 언어를 가시화 시킬 수 있고 시스템 구조와 모든 상세 내역에 대해 문서화하여 모델링하는 기능들을 제공하며, 다양한 모델링 도구로서의 다이어그램들로 이루어져 있다.

######UML Diagram의 종류에 대해 나열하고 설명해보아라

- 클래스 다이어그램 : 클래스 별로 연관관계를 나타내는 다이어그램

- 유스케이스 다이어그램 : 행위자(Acter)와 UseCase로 구분되어 그려진다.

- 상태 다이어그램 : 현재 상태를 나타내는 다이어그램

- 시퀀스 다이어그램 : 시간의 흐름에 따라서 나타내는 다이어그램

- 액티비티 다이어그램 : 처리과정, 수행되는 동안 일어나는 일을 나타낸다.



######프로젝트 관리 모형 종류에 대해 나열하고 설명해보아라

- 폭포수 : 각 단계를 확실히 매듭 짓고 그 결과를 철저하게 검토 후 승인, 이전 단계로 돌아가기 어려움으로 확실하게 검토해야 함
- 프로토타입 : 사용자의 요구 사항을 정확히 파악하고 결과물을 예측하여 만들어내는 모형물, 사용자에게 미리 보여줄 수 있지만 결과물과 조금 다를 수도 있고 단기간에 만들어야 한다.
- 나선형 모델 : 가장 현실적인 모형으로 비교적 최신형태이다. 점진적으로 개발 과정이 순환하며 진행된다.


######아키텍처란?

- 소프트웨어의 관점에서 본 하드웨어의 논리 규격을 나타낸다. 기능적 물리적 구조를 표현한다.

######프레임워크란?

- 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스 프레임과 인터페이스 프레임의 집합
- 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성되며, 컴포넌트들은 재사용이 가능하다.
- 스켈레톤 코드라고도 불리는데, 특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업 시간을 줄여주는 것이다.

- 장점 : 개발 시간을 줄일 수 있고, 오류로부터 자유로울 수 있다.

- 단점 : 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해질 수도 있다.

- 라이브러리와 프레임워크의 차이
  1. 라이브러리는 어플리케이션에서 호출할 수 있는 함수와 루틴으로 구성되어 있음

  2. 프레임워크는 어플리케이션에서 특정 기능들을 제공하기 위해 확장할 수 있는 일반적이고 상호 협력적인 컴포넌트를 제공

> 웹 프로그래밍

######HTML5의 특징

DOCTYPE이 간편해짐 : <!DOCTYPE html>

따옴표로 둘러싸지 않아도 됨

Input 태그에 email type을 쓰면 알아서 이메일만 입력받음

시맨틱 태그의 사용(Header, Footer)

Audio, Video의 지원

정규표현식을 사용가능(pattern="")



######웹의 흐름과 왜 CGI, 웹 어플리케이션 방식이 나왔는지에 대해서 설명하여라

- 초창기에 HTML로 개발된 웹 페이지는 동적으로 데이터를 처리해 줄 수가 없었다.

- 동적으로 DBMS를 통해서 데이터를 처리해주는 웹 페이지를 만들기 위해 CGI 방법이 나왔으며 이는 웹 서버가 프로그램을 바로 실행하는 방식(2-tier)이고, 웹 어플리케이션 방식은 중간에 웹 어플리케이션이 프로그램을 실행하는 방식(3-tier)이다.


######WAS란?
- Web Application Server의 약자이며, 주로 톰캣 IIS를 의미한다.
- 동적인 웹 페이지를 구성할 때 사용된다.
- 흔이 이제는 Web Server와 함께 불리며 이는 아파치가 가장 대표적이다.
* 주로 아파치+톰캣으로 설치와 배포가 된다.

![3-iter](http://cfile24.uf.tistory.com/image/2411084E588AEB3A068436)
- 3-tier 아키택처는 웹 서버와 DB를 논리적으로(혹은 물리적으로) 분리했다. DB의 접속은 서버를 통해서만 가능하도록 구성했다. 웹 서버는 클라이언트의 접속과 웹 애플리케이션의 비즈니스 로직, 그리고 DB접근을 담당했다. 더이상 데이터는 관리하지 않았다

![](http://cfile25.uf.tistory.com/image/245A8D3B588C411E2C560B)
▶ WAS를 활용한 웹 애플리케이션 아키택처

- 각각의 역할은 다음과 같다.
◎ Client: 사용자의 PC, 웹 브라우저이다.
◎ Web Server: Client의 요청과 접속관리를 주관한다.
◎ WAS: 실질적인 애플리케이션 실행(비즈니스로직과 DB접근)을 주관한다.
◎ DB: 데이터베이스. 데이터가 저장된 공간.

 - Server Layer의 웹 서버(Web Server)와 WAS를 구분한 것이 핵심이다. WAS가 웹 애플리케이션 실행을 주관하고, 웹 서버는 서버의 자원 및 클라이언트를 주관한다. 이렇게 클라이언트의 접속관리와 앱 실행을 분리함으로써 여러 클라이언트가 접근해도 비즈니스 로직 처리를 쓰레드로 할 수 있다. (그 결과 동시성 제어가 화두로 떠올랐고, 대부분 프레임워크에서는 이를 지원한다.)


- 마지막으로, 위 그림의 FLOW를 간략히 정리하면 아래와 같다.
① 클라이언트의 웹 브라우저가 HTTP Request를 한다.
② 웹 서버는 WAS에 웹 애플리케이션 실행을 위임한다.
③ WAS는 해당하는 로직을 수행하다가 DB접근이 필요하면 SQL 질의를 한다.
④ 질의에 따른 응답을 보낸다.
⑤ 실행 결과를 반환한다.
⑥ WAS로 부터 받은 결과를 웹 브라우저에 HTTP로 송신한다


###### 미들웨어
- 최근에 네트워크 상호 호환과 연동상태를 관리하는 분산 환경에 관심을 갖고 데이터베이스,
 스프레드쉬트, 윈도우 OLE등 다양한 소프트웨어를 다루는 데 더 관심을 가짐.
- 이러한 공통의 인터페이스를 준수하는 컴포넌트 기반의 소프트웨어는 많은 장점을 제공함.
- 이러한 공통의 인터페이스를 프레임웍=미들웨어(Middleware)라고 함

######웹 서버에서 프로세스 방식과 스레드 방식에 대한 차이점을 설명하여라

- 프로세스 방식의 경우 사용자가 웹 페이지를 요청할 때마다 서버는 계속해서 프로세스를 생성해주어야 한다.
이에 반해 스레드 방식의 경우 새로운 할당이 필요없이 스레드를 생성해주면 된다.


######웹 컨테이너(Web Container)란?

- 웹 서버의 내부에서 Servlet 클래스 또는 JSP 파일을 실행하기 위한 실행 환경을 제공하는 역할을 하는 것
- Servlet과 JSP를 사용한 웹 서버는 크게 URL 주소의 해석을 맡아 주는 HTTP 서버와 Servlet 클래스 또는 JSP 파일의 실행 요청을 처리해주는 웹 컨테이너로 구성된다.


######Servlet의 2가지 형식에 대해 설명해보아라

- GenericServlet과 HttpServlet이 존재하며 이는 서로 부자 관계이다. 많이 쓰이는 것은 주로 HttpServlet이며, GenericServlet은 프로토콜로부터 독립된 Servlet이다.
- Servlet은 내장객체가 존재하지 않는다. 따라서 일일히 만들어 줘야 하는데, 주로 View 부분은 JSP를 사용하고 Controller 부분은 Servlet을 사용한다.


#####Servlet 이란?
- Servlet: 자바 플랫폼에서 웹 앱을 개발할 때 사용하는 핵심기술. 컨트롤러와 뷰의 역할 분담이 가능해진다. 자바 API를 모두 사용할 수 있으며 다양한 서버 환경에서 실행 가능하다. 스레드를 기반으로 한다.
- Servlet Container: Servlet을 서버에서 실행하기 위한 서버 프로그램(서버는 서블릿 자체를 직접 실행할 수 없기 때문). JVM을 내장하고 있다.


######Servlet의 라이프 사이클에 대해 설명해보아라
1) 서버를 실행시키는 순간 서블릿의 생성자가 호출된다.
2) 생성자를 호출해서 객체가 생성되면 초기화 작업을 한다(init() 메소드가 최초 한번만 자동으로 호출).
3) 초기화 작업 후에는 Service 메소드가 호출이 된다(req, res를 통해 data get, login 구현 등의 작업이 일어남)
** Service 메소드는 클라이언트가 요청할 때마다 호출이 됨**
4) 마지막으로 서버가 종료되는 시점에 destory() 메소드를 호출한다(혹은 서버 재시작 시에 자원 반납을 위해 호출)

###### API : 자바 API (Application Programming Interface)
 - 자바개발 환경에서 제공되는 거대한 패키지.
 - 자바언어는 작고 단순한 대신 많은 기능들을 제공하는 라이브러리를 API로 가지고 있음.

##### Applet
 - 자바 애플릿 프로그램은 애플릿 뷰어(JDK에 포함)나 www(웹)검색기(웹브라우저)에 의해서   실행되는 작고 간단한 프로그램.
 - 일반적으로 애플릿 프로그램은 인터넷과 연동된 웹 서버로부터 사용자의 컴퓨터로 다운로드  되어 검색기 상에서 실행됨.
 - 애플릿 프로그램은 실행명령에 의해 실행되지 않고 웹의 HTML 코드 내에서 호출되는 실행
 형태를 가지고 있음.

######JSP란 무엇이고 사용하는 이유를 설명해보아라
- 서블릿의 단점(복잡한코드)을 보완 한 스레드 기반의 웹 어플리케이션 개발 기술
- 스크립트 코드 처리 방식
- 자바 언어를 기반으로 하기 때문에 자바 코드를 그대로 사용 가능
- 서블릿 / EJB 기능들과 잘 융합

8. JSP 라이프 사이클(생명 주기)
  - JSP 변환 서블릿 프로그램은 jspInit(), jspService(), jspDestroy()의 세 가지 메서드에 의해서 초기화, 서비스, 파괴의 과정을 거친다.
  - jspInit() 메서드는 단 한번 호출하며 jspService() 메서드는 서비스 요청이 있을 때마다 호출하게 된다. 즉, 클라이언트에서 JSP 문서를 클릭하게 되면 JSP 문서는 Servlet으로 변환되고, 그 변환된 Servlet에서 처음으로 jspInit() 메서드가 호출된다.
  - jspInit() 메서드는 JSP 에서 변환된 Servlet의 초기화 및 서비스를 시작하기 위한 준비를 하는 메서드이다. 그리고 서블릿에서 init() 메서드가 service() 메서드를 호출하듯이 JSP의 jspInit() 메서드는 jspService() 메서드를 호출한다. 호출된 jspService() 메서드는 클라이언트에서 요구한 작업을 수행하는 메서드이다.

######JSP 에서 페이지 이동 방법의 대해 설명 하시오.

 ① Forward 방식

      - Url이 바뀌지 않음. 요청객체와 응답객체가 유지됨.
      - 속도가 빠르며 요청객체에 소속 되어 있음.
      - 처리 구조 : 요청이 들어오면 Servlet이 받음.
      - 요청에 알맞은 페이지를 찾음. 알맞은 페이지가 있다면 응답.
      - 알맞은 페이지가 없다면, Forwarding 방식으로 알맞은 페이지로 넘기는데, 요청객체와 응답 객체를 포함해 넘김.
      - Url이 바뀌지 않은 상태로 응답 페이지를 통해 응답.

 ② Redirect 방식

    - Url이 바뀜. 요청객체와 응답객체가 유지 되지 않음.
    - 속도가 느리며, 응답객체에 소속 되어 있음.
    - 처리 구조 : 요청이 들어오면 Servlet이 받음.
    - 요청에 알맞은 페이지를 찾음. 알맞은 페이지가 있다면 응답.
    - 알맞은 페이지가 없다면, 알맞은 페이지로 다시 요청하게끔 응답 보냄.
    - 클라이언트는 응답을 받고, 다시 그 요청의 맞는 Url로 요청함.

######Servlet과 JSP의 차이점에 대해 설명해보아라

- Servlet : Container가 이해할 수 있게 구성된 순수 자바 코드로만 이루어진 것(HTML in JAVA)
- JSP : HTML 기반에 자바 코드를 블록화하여 삽입한 것(JAVA in HTML)


######모델 1, 2 MVC 패턴에 대해 설명해보아라
- MVC 패턴:  소프트웨어 개발에 사용될 세 가지 구성요소 또는 객체를 제안한다.
- Model : 소프트웨어 응용과 그와 관련된 고급 클래스 내의 논리적 데이터 기반 구조를 표현(사용자 인터페이스에 대한 어떠한 정보도 가지고 있지 않음)
- View : 사용자 인터페이스 내의 구성요소들을 표현하는 클래스들의 집합(사용자가 화면상에서 보고 응답할 수 있는 모든 것들)
- Controller : Model과 View를 연결하고 있는 클래스들을 대표하며, 이들 간에 통신하는데 사용된다.

① Model 1 : 디자인 코드와 자바 코드(비즈니스로직)를 구분하지 않고, 하나의 JSP일 내에 기술해서 웹 프로그램을 제작 하는 방식.
특징
- 개발하기가 쉽고, 배우기가 쉬움.
- 디자인코드와 비즈니스로직의 구분이 명확하지 않아, 복잡도가 높음.
- 수정 시 디자이너와 개발자의 협업이 필요.
- 비즈니스로직의 재 사용성이 어려우며, 유지 보수가 힘듬.

② Model 2 : 웹 어플리케이션을 개발할 때, MVC패턴을 적용하여, 웹 어플리케이션의 개발이
가능하도록 구현한 것.
특징
- 초기 설계에 많은 시간이 소요.
- 디자인코드와 비즈니스로직이 분리되며, 비즈니스로직의 재사용성이 높아짐.
- 비즈니스로직 계층의 확장성이 용이하며, 유지보수가 편하다.


######DAO와 DTO에 대해서 설명해보아라
DAO : Data Access Object로 직접 DB에 접근하는 부분을 코딩한다.
DTO : Data Transfer Object로 데이터들을 객체(모델)로 만드는 부분을 코딩한다.



######request, response, session에 대해 설명해보아라

- request : 클라이언트에서 전달된 파라미터 값을 전달 받을 때 사용하는 객체

- response : 클라이언트의 요청에 대한 응답을 처리할 때 사용하는 객체

- session : 클라이언트 세션 정보를 처리할 때 사용하는 객체



######Session과 Cookie의 차이점과 사용용도에 대해 설명해보아라

(공통) 사용이유 : 현재 우리가 인터넷에서 사용하고 있는 HTTP 프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP 프로토콜을 이용하게 되는 웹 사이트에서는 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속적으로 유지시키기 위해 Session과 Cookie를 사용한다.

http://jeong-pro.tistory.com/80?category=793347 : 사이트 참고
- HTTP 프로토콜의 특징 : 비연결지향, 상태정보유지안함

- Session : 특정 웹 사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한 번의 방문을 의미한다. Cookie와는 다르게 개인 아이디와 비밀번호와 같은 <u>웹 사이트의 데이터는 Client가 아닌 Server 측에 저장되거나 웹 브라우저의 캐시에 저장</u>되어 브라우저가 닫히거나 서버에서 삭제 시 사라진다.

- Cookie : 특정 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해주는 정보이다. 이러한 Cookie 정보는 인터넷 사용자가 특정 웹 서버에 접속할 때 생성되며, 개인 아이디 및 비밀번호, 방문한 사이트의 정보 등을 담은 임시파일로써 Server측이아닌 Client측에 텍스트파일로 저장되어 다음에 해당 웹 서버를 찾을 경우 웹 서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.


######GET방식과 POST방식의 차이점에 대해 설명해보아라
- 서블릿에서 데이터를 처리 하는 방식은?

  ① GET  : 서버에 있는 정보를 가져오기 위해 설계 됨. 240바이트까지 전달 할 수 있음. POST 방식에 비해 속도가 빠름. 검색엔진에서 검색단어 전송에 많이 이용함.  URL노출로 보안성이 요구되는 경우엔 사용 할 수 없음.

  ② POST : 서버로 정보를 올리기 위해 설계 됨. URL에 파라미터가 표시 되지 않음. 내부적으로 데이터가 이동함. GET 방식에 비해 속도 느림. 데이터크기 제한 없음.
  쿼리스트링(문자열) 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 객체들의 값도 전송가능.

- Get과 Post 차이점

  - Get은 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용
  - Post는 웹 브라우저가 웹 서버에 데이터를 전달하기 위해 사용.
  - Get을 사용하면 웹 브라우저에서 웹 서버로 전달되는 데이터가 인코딩되어 URL에 붙는다.
  - Post방식은 전달되는 데이터가 보이지 않는다.
  - Get방식은 전달되는 데이터가 255개의 문자를 초과하면 문제가 발생할 수 있다.
  - 웹서버에 많은 데이터를 전달하기 위해서는 Post 방식을 사용하는 것이 바람직하다.



######Statement와 prepareStatement의 차이점에 대해 설명해보아라
- Statement 와 PreparedStatement의 차이
  ① Statement : 정적 쿼리 시 사용. 매번 파싱과정을 거쳐야 함.(부하가 생길 수 있음) SQL문 전체를 명확히 알 수 가 있어서 디버깅이 쉬움.
  ② Prepared Statement : 동적 쿼리 시 사용.  한번 파싱하면 그 동일 SQL문장을 곧 바로 파싱 과정 없이 Execution 가능. (반복적인 다량의 SQL 수행 시 성능 상 이득이 있음) . 오류발생 시, 변수에 입력되는 값을 알 수 없어서 디버깅이 어려움.



######웹 개발자로 지원한다면, back-end와 front-end의 차이점에 대해 설명해보아라

front-end의 경우 클라이언트와 연관된 곳을 개발한다.

back-end의 경우 클라이언트와 직접적인 개입보다는 기술적인 기능(서버측)을 개발한다.



######XML이란?

- XML(extensible markup language)의 약어로써, 구조화된 문서를 웹 상에서 구현할 수 있는 인터넷 프로그래밍 언어를 뜻한다.

- HTML은 웹 상에 문서정보를 구현하는데 많은 역할을 해왔으나 날로 늘어가는 정보들을 좀 더 구조화된 형태로 표현하기에는 한계가 있었다. 반면 문서의 구조적인 정보를 갖고 있는 XML 문서는 웹 상에서 검색의 용이함과 체계적이고 일관적인 접근, 재가공의 용이함 때문에 HTML과 인터넷 문서 표준 포맷이 되었다.


######자바스크립트의 특징과 장 / 단점에 대해 설명해보아라

- 이벤트 중심의 프로그래밍 언어
- 인터프리터 언어(클라이언트의 웹 브라우저에 의해 해석되고 실행, 웹 브라우저에서 웹 문서(HTML)를 실행할 때 프로그램 코드가 해석)
- HTML 문서 내에 기술되어지고 HTML 문서와 함께 수행되어지는 언어
- HTML 문서에 삽입해서 사용하는 스크립트 언어
- 객체 지향적 특성을 모두 가지고 있다고 말할 수는 없지만, 객체를 정의하여 사용할 수 있는 객체 기반의 언어
- 장점 : HTML 문서 내에 작성할 수 있으므로 개발속도가 빠르고, 웹 브라우저에서 동작하는 스크립트 언어로 운영체제(플랫폼)의 제한을 받지 않는다.

- 단점 : 웹 브라우저 상에서 소스 코드가 노출된다. 컴파일하지 않는 인터프리터 언어이므로 복사하여 그대로 사용할 수 있다. 객체와 객체 함수가 한정되어 있다.



[] Prototype이란?



###### AJAX란?
① 웹클라이언트 화면 제어를 보다 세밀하게 하기 위한 기술.

② 특징
 - 필요한 데이터만 서버로 보내고 해당 정보만 받음.
 - 서버로부터 정보를 받을 때는 xml or josn 형태로 받고, Client에서는 그 정보들을 DOM을 통해 화면을 재가공하여 보여주므로 서버와 교환되는 데이터의 양이 적어지므로 점유율을 낮출 수 있음.
 - Client에서의 데이터 처리로 서버에 부담이 덜 가므로 다른 응답 요청에 신속히 응대.

###### proto란?

- 상위에서 물려 받은 객체의 프로토타입에 대한 정보(Prototype link라고도 함)

######프로퍼티란?

- 생성자에 의한 객체 생성 시 메모리 낭비를 줄이기 위해 사용하는 메소드들의 집합

######리터럴이란?



> 네트워크

###### OSI 7 Layer와 각 계층에 대한 설명을 해보아라

- OSI 7 Layer : 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약으로 다음과 같이 분류된다.

1) 물리계층 : 전송하는데 필요한 기능을 제공. 장비로는 통신 케이블, 허브가 존재한다.

2) 데이터링크계층 : 송/수신을 확인. MAC Address를 가지고 통신. 장비로는 브릿지와 스위치가 존재한다.

3) 네트워크계층 : 패킷을 네트워크 간의 IP를 통하여 데이터를 전달. 장비로는 라우팅이 존재한다.

4) 전송계층 : 두 호스트 시스템으로부터 발생하는 데이터의 흐름을 제공한다.

5) 세션계층 : 통신 시스템 사용자간의 연결을 유지 및 설정한다.

6) 표현계층 : 세션 계층 간의 주고받는 인터페이스를 일괄성 있게 제공한다.

7) 응용계층 : 사용자가 네트워크에 접근할 수 있도록 서비스를 제공한다.

① 개요

    컴퓨터 통신 분야에서 동일 업체 또는 유사 업체기리의 다양한 표준들이 양산됨에 따라 표준
    을 정의하는 골격으로서의 국제적인 기준 모델이 필요하게 되었다. 따라서 네트워크 상호
    의 접속을 목적으로 각종 규격 개발작업을 조정하기 위한 공통 기반을 제공하고, 각 사업
    별로 개발된 기존 규격에 대하여는 이러한 참조 모델에 쉽게 적응, 연결토록 하는 편의
    을 제공하고자 했다.



 ② 표준화를 위한 기본 골격

    개방형 시스템간 상호접속모델(Open System interconnection model)은 각 계층에서 표준이
    개발, 발전될 수 있도록 기본들을 제공, 프로토콜의 발전을 유도, 인도하는데 목적이 있다
    결론적으로 OSI 참조모델은 표준의 표준으로써 단지 표준화의 유도를 위한 기본 골격이다.



 ③ 계층 간 독립성

    각 계층별로 독립시킨다는 것은 융통성(flexibility)을 부여함을 의미한다.
    예를 들어 보다 좋은 성능을 가진 전기적 인터페이스가 개발되면 상위계층에 영향을 미치
    지 않고 성능을 향상시킨 채 교체가 가능하기 때문이다.



 ④ 계층 내 프로토콜

    OSI가 각 계층별로 하나의 프로토콜만이 존재하는 그릇된 생각을 할 수 있는데 이는 잘못이며사실은 각 층을 구현하기 위해 다양한 프로토콜이 존재한다. 그러나 같은 계층에 있는 여러 다른 프로토콜은 바로 하위 계층에서 제공하는 서비스를 공유하여야 한다.

 ⑤ 연결 지향성 및 비연결성

    OSI는 초기에 연결 지향성 서비스 위주의 프로토콜들에만 관심을 가져왔으나 후에 비연결성에도 관심을 가지게 되었다.


######이더넷 프로토콜에서 사용하는 이더넷 프레임의 구조에 대해 설명해보아라

- 프레임 구조는 각 필드로 구성되어 있으며, 각 필드의 단위는 바이트이다. 각 필드는 헤더, 데이터, 트레일러 부분으로 구분되며 보다 세부사항은 다음과 같다.
- 헤더 : Preamble(7) - STartDelimiter(1) - DesAddress(2or6) - SrcAddress(2or6) - Length(2)
- 데이터 : Data(0~1,500)
- 트레일러 : Pad(0~46) - Checksum(4)

######소켓 통신(TCP/UDP)

TCP(Transmission Control Protocol)
- 연결형 서비스 제공
- 높은 신뢰성 보장
- 연결의 설정(3-way handshaking)
- 연결의 해제(4-way handshaking)
- 데이터 흐름 제어, 혼잡 제어
- 전이중, 점대점 서비스(양방향 송수신 서비스)

UDP(User Datagram Protocol)

- 비연결형 서비스 제공
- 신뢰성이 낮음
- 데이터의 전송 순서가 바뀔 수 있음
- 데이터 수신 여부 확인 안함(3-way handshaking과 같은 과정 X)
- TCP보다 전송속도가 빠름

####### http와 https
    - http
      인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약이다. 하이퍼텍스트는 문서 중간중간에 특정 키워드를 두고 문자나 그림을 상호 유기적으로 결합하여 연결시킴으로써, 서로 다른 문서라 할지라도 하나의 문서인 것처럼 보이면서 참조하기 쉽도록 하는 방식을 의미한다.

    - https
      https란 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer) 프로토콜을 이용하여 데이터를 전송하고 있다는 것을 의미한다. SSL 프로토콜은 테리사(Terrsa)가 개발해 Netscape사가 NetSite의 암호화 중심 프로토콜로 정착시킨 기술로 정보 암호화시 공개키(Pubilc Key)와 개인키(Private Key)라는 두가지 키를 이용하는 방법이다.
      공개키(Public Key)는 인터넷 상에 공개되어 있는 키로 서버에서 자동으로 이용자님의 브라우져로 보내며, 이용자가 입력한 정보는 이 공개키(Public Key)를 이용하여 암호화되어 다시 서버까지 전달된다.
      이 공개키(Public Key)로 암호화된 정보는 서버만이 유일하게 소유하고 있는 개인키(Private Key)로만 해독이 가능하다.
      제3자가 의도적으로 암호화된 이용자 정보를 가로챈다 하더라도, 서버의 개인키(Private Key)가 없는 한은 해석이 불가능하다.


> 자바 프로그래밍

1. JAVA

- JAVA는 네트워크상에서 쓸 수 있도록 미국의 선 마이크로 시스템즈가 개발한 객체 지향 프로그래밍 언어

2. JAVA의 특징
  a. 자바가상머신(JVM)만 설치하면 컴퓨터의 운영체제에 상관없이 작동한다.(즉, 운영체제에 독립적)
  b. 기본 자료형을 제외한 모든 요소들이 객체로 표현
  c. 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
  d. Garbage Collector를 통한 자동적인 메모리 관리
  e. 멀티쓰레드(Multi-thread)를 지원

3. OOP(객체지향 프로그래밍)
- OOP란 Object-Oriented Programming의 약어로써 객체지향 프로그래밍을 의미
- 데이터를 객체로 취급하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는다르게 객체와 객체의 상호작용을 통해 프로그램이 동작하는 것을 말한다.

3-1. OOP 특징
  a. 객체지향 프로그래밍은 코드의 재사용성이 높다.
  b. 코드의 변경이 용이
  c. 직관적인 코드분석
  d. 개발속도 향상
  e. 상속을 통한 장점 극대화

  - 캡슐화(Encapsulation): 하나의 문제 해결을 위한 data와 method를 한 단위로 묶는 것으로서,  클래스 내부 정의에 대해 외부에서 볼 수 없도록 함이 특징(은닉화)
 - 추상화(Abstraction)  : 모델(Object)의 자세한 성질을 무시하고(숨기고) 그들의 일반적인 성질 을 나타낸다는 것. 일반적으로 클래스는 클래스로 표현할 서브클래스(또는 객체)의 공통적인 성질과 행위를 일반화해 디자인되며 그로부터 생성된 객체는 자신의 고유한 성질을 갖게 됨.

  **Interface, Abstract**
  < Interface >
- 일종의 추상 클래스
- 오직 추상메서드와 상수만을 멤버로 갖는다.
- Implements 키워드를 사용
- 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.
- Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.

< Abstract >
- 추상메서드를 하나 이상 가진 클래스
- 자신의 생성자로 객체 생성 불가능
- 하위 클래스를 참조하여 상위 클래스의 객체를 생성
- 하위 클래스를 제어하기 위해 사용

  > Interface vs Abstract공통점

  - new 연산자로 인스턴스 생성 불가능.
  - 프로토타입만 있는 메서드를 갖는다.
  - 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.

  > 차이점
  - 사용하는 키워드가 다르다.
  - Abstract는 일반 메서드를 사용할 수 있지만, Interface는 메서드 선언만 가능하다.


- 다형성(Polymorphism) : 다형성이란 같은 메시지에 대해 클래스에 따라 다른 행위를 하는 특성.일반적으로 같은 이름을 갖는 method에 대해 인자(Agument) 개수와Data Type에 따라 수행되는 행위가 달라짐을 의미. 다형성을 통해사용자는 약속된 인터페이스를 따르는 서로 다른 객체들를 같은 방식으로 사용할 수 있게 됨.

  Overloading vs Overriding
    Overloading(오버로딩)
    - 같은 이름의 메소드를 여러개 정의하는 것
    - 매개변수의 타입이 다르거나 개수가 달라야 한다.
    - return type과 접근 제어자는 영향을 주지 않음.
Overriding(오버라이딩)
  - 상속에서 나온 개념
  - 상위 클래스(부모 클래스)의 메소드를 하위 클래스(자식 클래스)에서 재정의

- 상속(inheritance)   : 기존에 있던 클래스(즉, 기존의 클래스로부터 상속받은)를 바탕으로 다른 특성을 추가해 새로운 클래스를 만들 수 있음.

 - 인스턴스(Instance)  : 인스턴스는 추상화 개념 또는 클래스 객체, 컴퓨터 프로세스 등과 같은 템플릿(무엇인가를 만들 때 안내 역할 하는 데 사용되는 형식, 꼴,틀 또는 모형 등을 의미)이 실제로 구현된 것.

4. Object

- Object(객체)는 OOP에서 데이터(변수)와 그 데이터에 관련되는 동작(함수). 즉 절차, 방법, 기능을 모두 포함한 개념
- 예)기차역에서 승차권을 발매하는 경우, 실체인 '손님'과 동작인 '승차권 주문'은 하나의 객체이며, 실체인 '역무원'과 동작인 '승차권 발매'도 하나의 객체이다.
- 같은 성질, 같은 구조와 형태를 가지는 객체는 등급으로 정의하고 등급에 속하는 객체는 그 등급의 인스턴스라고 한다.

5.  String, StringBuffer, StringBuilder의 차이점
  ① String   클래스 : 상수 문자열, 한번 생성한 후 변하지 않는 문자열 용도.
  ② StringBuffer  클래스 : 프로그램 내에서 계속 변하는 문자열 용도.
  ③ StringBuilder 클래스 : Java5에 추가된 클래스로 StringBuffer와 기능이 같다.

   * 차이점 : StringBuffer는 동기화(synchronized)되지만 StringBuilder는 그렇지 않다.
   즉, StringBuilder는 다중 thread에서는 안전하지 않으므로 동기화가 필요한 경우는 StringBuffer를 사용하는 것이 좋다. StringBuilder에서 동기화 하려면 synchronized블록 으로 감싸야 한다

6. Call by Reference, Call by Value
  - Call by Reference - 매개 변수의 원래 주소에 값을 저장하는 방식. 클래스 객체를 인수로 전달한 경우
  - Call by Value - 인수로 기본 데이터형을 사용. 주어진 값을 복사하여 처리하는 방식. 메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않는다.

7. Static의 의미
 - 클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미   
 - 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(객체와 무관한 키워드)

8. Garbage Collection(가비지 컬렉션)
 시스템에서 더이상 사용하지 않는 동적 할당된 메로리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것으로 시스템에서 가비지컬렉션을 수행하는 부분을 가비지 컬렉터라 부른다.

9. Primitive type과 Reference type
 Primitive type - 변수에 값 자체를 저장
 정수형 byte, short, int, long
 실수형 float, double
 문자형 char
 논리형 boolean

 * Primitive type은 Wrapper Class를 통해 객체로 변형할 수 있다.
 예) int→Integer, char→Character(int와 char를 제외한 Primitive type의 다른 자료형들은 맨 앞 알파벳을 대문자로 바꿔주면 된다. float→Float)
 * Reference type - 메모리상에 객체가 있는 위치를 저장
 종류 - Class, Interface, Array 등

 10. Wrapper Class
 Primitive type으로 표현할 수 있는 간단한 데이터를 객체로 만들어야 할 경우가 있는데 그러한 기능을 지원하는 클래스

 11. Spring Framework(스프링 프레임워크)
  - 자바(JAVA) 플랫폼을 위한 오픈소스(Open Source) 애플리케이션 프레임워크(Framework)
  - 자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임워크
  - 자바 개발을 위한 프레임워크로 종속 객체를 생성해주고,  조립해주는 도구
  - 자바로 된 프레임워크로 자바SE로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할

 스프링 특징 간단히

 - 크기와 부하의 측면에서 경량.
 - 제어 역행(IoC)이라는 기술을 통해 애플리케이션의 느슨한 결합을 도모
 - 관점지향 프로그래밍(AOP)을 위한 풍부한 지원
 - 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음
 - 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음

 스프링 특징 자세히

 a. 경량 컨테이너로서 자바 객체를 직접 관리. -> 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
 b. 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크.

      일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.

 c. 스프링은 제어의 역행(IoC : Inversion of Control)을 지원.

    컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.

 d. 스프링은 의존성 주입(DI : Dependency Injection)을 지원

    각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.

 e. 스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원

    따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.

 f. 스프링은 영속성과 관련된 다양한 서비스를 지원

    iBatis나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.

 g. 스프링은 확장성이 높음.

    스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.

    - 실행 순서(실행구조) :
      1. web.xml의 등록된 DispatcherServlet를 통해서 요청에 대해 진입.
      2. DispatcherServlet은 Client로부터 들어온 URL을 HandlerMapping 라는 곳으로 전송 후
      3. URL을 분석해서 알맞은 Controller 이름을 다시 DispatcherServlet으로 보냄.
      4. HandlerMapping이라는 것을 통해서 실행될 Controller의 이름을 입력받은
      5. DispatcherServlet은 전달받은 Controller를 실행시킴. 이렇게 실행된 Controller는 스프링에서 제공하는 ModelAndView 객체에 뷰 페이지에 전달할 객체와 View Page 이름 정보를 담고 DispatcherServlet으로 보냄.
      6. ViewResolver를 통해 보여 질 View페이지를 탐색한 후 View페이지를 보여줌.

     - DI 와 AOP의 대해 설명하시오.
       - DI : Dependency Injection의 약자 의존성 주입이란 뜻. 스프링을 적용하여 applicationContext.xml에서 설정만 해주면, 외부 설정파일(xml)에서 연관관계에 있는 객체를 주입해주기 때문에 의존객체를 찾기 위한 코드가 필요하지 않게 됨. 즉, 외부설정에서 객체를 찾아서 쓰기 때문에 코드 내에 의존관계를 맺는 코드 생성이 불필요.
      - AOP : Aspect oriented programming의 약자 관심지향 프로그래밍.
        프로그래밍을 할 때 특정한 관심사를 가진 코드 부분을 별도의 모듈로 분리함으로써, 기존 객체지향의 강력한 기능(상속, 위임)만으로는 처치가 곤란했던 중복을 제거 할 수 있게 됨.
        예를 들어 로깅과 같은 기본적인 기능이나, 트랜잭션, 보안등 어플리케이션 전반에 걸쳐 적용되는 공통 기능들은 어떤 특정 모듈에 한정적으로 필요한것이 아니라 어플리케이션 전반에 걸쳐 필요한 기능으로 핵심 비즈니스 로직과는 구분되며, 핵심 비즈니스 기능과 구분하기 위해 공통 기능을 공통 관심 사항(cross-cutting concern)이라고 표현하고, 핵심 로직을 핵심 관심 사항(core concern)이라고 표현 한다.



12. 접근제한자 (public > protected > default > private)

    public - 접근 제한이 없다.(같은 프로젝트 내에 어디서든 사용가능)
    protected - 같은 패키지 내, 다른 패키지에서 상속받아 자손클래스에서 접근 가능
    default - 같은 패키지 내에서만 접근 가능
    private - 같은 클래스 내에서만 접근 가능

13. JVM(Java Virtual Machine)
  : 자바 가상 머신으로 자바 바이트 코드를 실행할 수 있는 주체

  - 즉, 운영체제 위에서 동작하는 프로세스로 <u>자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할수 있는 기계어로 바꿔 실행시켜주는 역할</u>

  - JVM의 구성 4가지
  ![memory](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTAZrWRwovVKuU_dAyjZN_21q7k3IeP8WDUHlgXfEGvvnKU-H5N)

  - 메소드 영역(Method area)
    메소드와 클래스 변수를 저장하기 위한 공간
    모든 프로그램에 의해 공유
  - 힙 영역(Heap area)
    동적으로 할당하여 사용할 수 있는 메모리 공간
    주로 실행시간에 생성되는 객체를 저장
  - 스택 영역(Stack area)
    메소드 호출 시 메소드의 매개변수, 지역변수, 임시변수 등을 저장하기 위한 스택 구조의 메모리
    실행중인 프로그램에 따라 스택 프레임 할당
  -  PC 레지스터
     JVM이 현재 수행할 명령어의 주소를 저장
  - Native 메소드 스택
    native() 메소드를 호출할 때 native() 메소드의 매개변수, 지역변수 등을 저장

14.  객체(object)
    효율적으로 정보를 관리하기 위하여 사람들이 의미를 부여하고 분류하는 논리적인 단위이다. 프로그래밍에서는 클래스에 정의된 내용대로 메모리에 생성된 것을 말함.

15. 클래스
    클래스(class)란 어떤 특정 종류의 모든 객체(object)들에 대해 일반적으로 적용할 수 있는 멤버 변수와 메소드를 정의한 소프트웨어적인 설계도(blueprint) 또는 프로토타입(prototype)이라 할 수 있다. 즉, 실세계에 존재하는 객체들이 가질 수 있는 상태와 행동들에 대해 소프트웨어적으로 추상화(abstraction) 해 놓은 것이 클래스(class)이다.


16. 객체와 인스턴스
   클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함.

17. 자바언어와 기존의 언어와의 다른 특징
    - 포인터를 사용하지 않는다. (포인터는 존재, 연산을 허용하지 않음)
    - 자동으로 garbage collection 기능을 수행한다.
    - 엄격한 형 검사(strict type checking)를 수행하여 에러를 조기에 발견한다.
    - 실행시간에 발생하는 에러를 처리한다.

18. 예외처리의 필요성과 목적
    - 예외는 프로그램 실행 중에 발생할 수 있는 명령어의 정상적인 흐름을 방해하는 이벤트로 자바에서 예외는 하나의 오브젝트 이다. 프로그램 실행 중에 메소드 안에서 에러가 발생할 경우, 메소드는 그 에러에 해당하는 예외 오브젝트를 만들고 그것을 자바 런 타임 시스템(runtime system)에 전해준다.
    -  예외를 사용하여 에러 처리 시 장점
        일반적으로 프로그램의 실행 코드와 에러를 처리하는 코드를 분류할 수 있다.
        메소드의 콜 스택(Call Stack)에 에러를 차례대로 보낼 수 있다.
        에러 타입을 종류별로 분류할 수 있다.

19.  Collection에서 데이터를 저장 하는 3가지와 그 특징
    - Set : 순서가 없고, 중복을 허용하지 않는 자료구조
    - List : 순서지정이 가능한 요소들의 집합으로 ArrayList, LinkedList, Vector를 포함한 여러 클래스에서 List interface가 구현되어있다.
    배열과 같은 구조지만, 가변적 길이를 가지고 있다. Set 과는 다르게 중복하는 요소를 추가 할 수 있다.
    - Map : key 값과 value값의 형식으로 저장되면 key 값은 절대 중복이 안 됨.(중복적인 키를 삽입하는 이전의 데이터를 덮어 씀),  Iterator가 없다.

  20. 스트림이 무엇이며 스트림의 특징은?
  - 스트림 : 데이터를 목적지로 입 · 출력하기 위한 방법. 스트림에 데이터를 쓸 수 있고, 데이터를 읽을 수 있음. 연결하고자 하는 Device에 따라 다양한 스트림이 존재.
  - 특징 : 스트림은 FIFO 구조.  읽기, 쓰기가 동시에 되지 않음.  읽기, 쓰기가 필요하다면 읽는 스트림과 쓰는 스트림을 각각 하나씩 열어 사용해야함. 데이터가 처리 되기 전까지 스트림에 사용되는 스레드는 데이터가 모두 전송되기 전까지 블록킹 상태에 빠짐.

 21. InnerClass 를 쓰는 이유
  - 내부 클래스를 사용하면 같은 패키지에 있는 다른 클래스한테 까지도 숨길 수 있기 때문에 outer class를 통하지 않고서는 접근할 수 없음. 보안성이 좋아짐.

22. iBatis(mybatis)
  - mybatis(IBATIS)는 퍼시스턴스(Persistence) 계층(데이터 처리 계층)의 프레임워크로 다른 객체 관계 매핑 프레임워크들과는 달리 정형화된 테이블 구조에 의존하지 않고 SQL 구문의 실행 결과에 객체를 매핑 하는 방식으로 테이블 구조가 복잡해지고 정규화 돼 있지 않더라도 테이블을 변경할 필요 없이 기존 개발 방법에서 사용한 SQL을 그대로 사용할 수가 있으며, SQL에 적용한 튜닝들도 모두 그대로 유지된다.
  - SQLMaps는 엄밀하게 말하면, 자바 빈즈를 PreparedStatement 파라미터와 ResultSet으로 매핑 시켜주는 기능을 담당한다.
  - Java에서 DataBase를 편하게 Handling 할 수 있게 해주는 프레임 워크.
  - 특징 : SQL문과 Java코드와의 분리 만으로도 Java개발자는 Query문을 신경쓰지 않아도 됨. SQL문이 변경되더라도 파라미터 값만 변경 되지 않는 다면 Java소스에서 수정할 부분이 없기 때문.
  - MVC 모델에서 커버하는 부분 : Model 지원.
  - 실행 순서(실행구조) :
    자바 코드 내에서 특정 쿼리문을 실행하기 원할 때, 파라미터와 필요한 조건을 넘기기 위한 객체를 생성.
    SQLMaps를 실행하기 위해 쿼리의 객체와 이름을 넘겨줌.
    쿼리가 실행되었을 때 SQLMaps는 쿼리 결과를 받기 위해 정의 된 클래스의 인스턴스를 생성하게 됨.
    인스턴스는 데이터베이스에 의해 반환 된 ResultSet 으로부터 만들어짐.
